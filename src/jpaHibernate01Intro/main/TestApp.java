    package jpaHibernate01Intro.main;

    import jpaHibernate01Intro.model.Employee;
    import org.hibernate.Session;
    import org.hibernate.SessionFactory;
    import org.hibernate.Transaction;
    import org.hibernate.cfg.Configuration;

    import java.io.Serializable;

    public class TestApp {

        public static void main(String[] args) {

            // Step 1. Creating a configuration object
            Configuration cfg = new Configuration();

            // Step2. configure hibernate.cfg.xml file to Configuration object
            cfg.configure();

            // Step3. Create SessionFactory Object
            SessionFactory sessionFactory = cfg.buildSessionFactory();

            // Step4. Get the Session Object from SessionFactory
            Session session = sessionFactory.openSession();

            // Step5. Begin the Transaction within a session
            Transaction transaction = session.beginTransaction();

            Employee employee = new Employee();
            employee.setEmpId(7);
            employee.setEmpName("dhoni");
            employee.setEmpSal(54846.3);

            // Step6. Perform operations
            Serializable object = session.save(employee);
            System.out.println(object);

            // Step7. Performing Transaction operations
            transaction.commit();

            // Step8. Close the session
            session.close();

        }
    }

    /*

    Two main problems with JDBC are:
    1.  JDBC code is not portable
    2.  We can't deal with Object injection to the database as jdbc query expects values

    To overcome limitations of jdbc we, we opt for ORM(Object Relational Mapping)
    Object Relational Mapping: where we can map sql table details with object details using
                                1. annotations
                                2. xml configuration

    JPA(JAVA PERSISTENCE API) is the api provided by sun microsystems through
    javax.persistence library to achieve object relational mapping

    Hibernate tool gives the implementation for the JPA Api

    To develop a Hibernate application, we have to use the following four files:
                1. Model class
                2. Mapping Code (xml/ optional if you use annotations)
                3. Hibernate Configuration file (xml)
                4. Test class

    1. Model class
    > It is also called Entity/POJO
    > This class must follow rules given by hibernate
          i. must have a package statement
         ii. must be a public class
        iii. all the variables must of private type
         iv. must have a zero argument constructor, getter and setter methods
          v. can have annotations given by JPA and core library also
         vi. can inherit (extends/implements) only hibernate api.
    2. Mapping Code
        Annotations: @Entity, @Table(name=""), @Id, @Column(name="")
        Entity.hbm.xml:
        <hibernate-mapping>
            <class name="" table="">
                <id name="" type="" column=""/>
                <property name="" type="" column=""/>
            </class>
        </hibernate-mapping>
    3. Hibernate Configuration file

        This file is used to configure database property details and entity class
        hibernate.cfg.xml:
        <hibernate-configuration>
            <session-factory>

                <!-- Database connection settings -->
                <property name="connection.driver_class">com.mysql.jdbc.Driver</property>
                <property name="connection.url">jdbc:mysql:///enterprisejavabatch</property>
                <property name="connection.username">root</property>
                <property name="connection.password">root123</property>

                <!-- JDBC connection pool (use the built-in) -->
                <property name="connection.pool_size">1</property>

                <!-- SQL dialect -->
                <property name="dialect">org.hibernate.dialect.MySQLDialect</property>

                <!-- Echo all executed SQL to stdout -->
                <property name="show_sql">true</property>

                <!-- Format SQLOutput to stdOut--->
                <property name ="format_sql">true</property>

                <!--Mapping information-->
                <mapping resource="Employee.hbm.xml"/>
                <mapping class = "in.ineuron.Model.Employee"/>

            </session-factory>
        </hibernate-configuration>

        org.hibernate.dialect library will generate the SQLQuery when the programmer performs operation.
        For every database dialect is different.
                Oracle => nature of query
                MySQL => nature of query

        <property name="show_sql">true</property>
        This property is used to see the Query generated by the dialect based
        on the database environment on the console.

        <property name="format_sql">true</property>
        This property is used to format the Query generated by the dialect based on the
        database environment on the console.

        <property name = 'hibernate.hbm2ddl.auto">[validate/create/update/create-drop]</property>
        validate =>hibernate creates no table, programmer should create or modify tables
        manually. This is default value.
        create => hibernate always creates new table,if table exists it will drop the table.
        update => hibernate creates new table,if table does not exists, otherwise it will
        reuse the same table.
        create-drop=>This option is used for testing purpose not in development creates a new
        table and perform operation,at last it will drop the table.

     4. Test class coding and its execution flow
        1. Create a configuration object
        2. Load hibernate.cfg.xml file into configuration object using configure().
        3. Build SessionFactory object using cfg which handles
        4. use SessionFactory and get Session object to perform Persistence operation.
        5. Begin Transaction, if the operation in Non-Select.
        6. Now perform operation using Session object.
        7. Commit or rollback if transaction has started.
        8. close the session at the end.

        Note: To specify the configuration details and mapping details we need to write xml file.
        If the filename is hibernate.cfg.xml then it promotes automatic loading,
        otherwise we need to read those data from "FileInputStream".

        Single Row Operations(SRO):

        a. insert query
            session.save(,) vs session.persist(,)

        b. select query
            session.load(,) => if the record is not available it would return "ObjectNotFoundException".
                 vs
            session.get(,) => If the record doesnt exists, it would return null.

        c. updateQuery
            session.update(,)
            session.saveOrUpdate(,)
                => first performs selection,record found, so latest values it updated using update query.
                => first performed selection,record not found, so perform insert operation.

        d. deleteQuery

        session.delete(,)=> Check whether record exists,only if it exists perform deletion.
        BulkOperation(multiple rows)
            1. HQL/JPQL
            2. NativeSQL
            3. CriterionAPI/QBC

     */